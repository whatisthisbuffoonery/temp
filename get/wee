total 16
drwxr-xr-x 3 dthoo 2025_singapore  118 Dec 17 04:25 .
drwxr-xr-x 9 dthoo 2025_singapore  186 Dec 17 02:52 ..
-rw-r--r-- 1 dthoo 2025_singapore 3720 Dec 17 03:00 get_next_line.c
-rw-r--r-- 1 dthoo 2025_singapore 1281 Dec 16 16:30 get_next_line.h
-rw-r--r-- 1 dthoo 2025_singapore 1651 Dec 16 16:30 get_next_line_utils.c
drwxr-xr-x 3 dthoo 2025_singapore  128 Dec 17 03:39 ohno
-rwxr-xr-x 1 dthoo 2025_singapore  276 Dec 17 04:25 run.sh
-rw-r--r-- 1 dthoo 2025_singapore    0 Dec 17 04:25 wee
total 24
drwxr-xr-x 3 dthoo 2025_singapore  128 Dec 17 03:39 .
drwxr-xr-x 3 dthoo 2025_singapore  118 Dec 17 04:25 ..
-rw-r--r-- 1 dthoo 2025_singapore  215 Dec 16 16:30 foo.txt
-rw-r--r-- 1 dthoo 2025_singapore 4885 Dec 17 03:51 get_next_line.c
-rw-r--r-- 1 dthoo 2025_singapore 1492 Dec 17 03:50 get_next_line.h
-rw-r--r-- 1 dthoo 2025_singapore 1728 Dec 16 16:30 get_next_line_utils.c
drwxr-xr-x 6 dthoo 2025_singapore  123 Dec 17 01:32 gnlTester
-rw-r--r-- 1 dthoo 2025_singapore   63 Dec 16 16:30 ree.txt

==== /home/dthoo/temp/get/get_next_line.c ====


#include "get_next_line.h"
/*
void	probe(char *a, int b, ssize_t c, ssize_t e)
{
	char d;
	if (a)
		write(1, " ye a ", 5);
	if (b)
		write(1, " ye b ", 5);
	ssize_t t = 1;
	if (c < 0)
	{
		write(1, "-", 1);
		c = 0 - c;
	}
	while (c / t > 9)
		t *= 10;
	while (t)
	{
		d = ((c / t) % 10) + 48;
		write(1, &d, 1);
		t /= 10;
	}
	t = 1;
	write(1, " | ", 3);
	if (e < 0)
	{
		write(1, "-", 1);
		e = 0 - e;
	}
	while (e / t > 9)
		t *= 10;
	while (t)
	{
		d = ((e / t) % 10) + 48;
		write(1, &d, 1);
		t /= 10;
	}
}
*/
char	*read_buf(t_var *file, int fd, int *done)
{
	ssize_t	i;
	ssize_t	k;
	char	*ret;

	k = -1;
	if (file->count >= file->lim || fd != file->fd)
		refresh_buffer(file, fd);
	if (file->lim < 1)
		return (NULL);
	i = file->count;
	while (file->count < file->lim && file->buf[file->count] != '\n')
		file->count ++;
	*done = (file->count < file->lim && file->buf[file->count] == '\n');
	file->count += *done;
	ret = malloc(((file->count - i) + 1) * sizeof(char));
	if (!ret)
	{
		file->count = i;
		file->lim = -1;
		return (NULL);
	}
	while (i + ++k < file->count)
		ret[k] = file->buf[i + k];
	ret[k] = '\0';
	return (ret);
}

char	*get_next_line(int fd)
{
	static t_var	file;
	char			*ret;
	char			*tmp;
	int				done;

	done = 0;
	ret = read_buf(&file, fd, &done);
	while (ret && !done && file.lim > 0)
	{
		tmp = read_buf(&file, fd, &done);
		if (!tmp)
		{
			if (file.lim == 0)
				break ;
			free(ret);
			return (NULL);
		}
		done += get_strjoin(&ret, tmp, 0, 0);//try to phase out for a faster solution
	}
	return (ret);
}
/*
#include <fcntl.h>

void ft_putstr(char *a, int flag)
{
	int i = 0;
	if (!a)
	{
		ft_putstr("(null)\n", 0);
		return ;
	}
	while (a[i])
		i ++;
	write(1, a, i);
	if (flag)
	{
		if (a[i - 1] == '\n')
			write(1, "nl\n", 3);
		else
			write(1, "empty\n", 6);
	}
}

void ft_putnbr(int n)
{
	int t = 1;
	char a;
	while (n / t > 9)
		t *= 10;
	while (t)
	{
		a = ((n / t) % 10) + 48;
		write(1, &a, 1);
		t /= 10;
	}
	write(1, "\n", 1);
}

int ft_strlen(char *a)
{
	int i = 0;
	while (a && a[i])
		i ++;
	return (i);
}

void read_file(int fd, size_t lines)
{
	char *a;
	if (!lines)
		lines = -1;
	while (lines--)
	{
		a = get_next_line(fd);
		
		if (a && a[0] == '\n')
			ft_putstr("nl\n", 0);
		if (a && a[0] == '\0')
			ft_putstr(".\n", 0);
		
		ft_putstr(a, 1);
		//ft_putnbr(ft_strlen(a));
		if (!a)
			return ;
		free(a);
	}
}

int main(int c, char **v)
{
	if (c < 2)
		return (1);
	ft_putnbr(BUFFER_SIZE);
	(void) v;
	int fd = open(v[1], O_RDONLY);
	if (fd < 0)
		return (1);
	read_file(fd, 0);
//	close(fd);
//	fd = open("not_a_file.txt", O_WRONLY);
//	fd = -100;
//	read_file(fd, 0);
//	fd = open(v[1], O_RDONLY);
//	if (fd < 0)
//		return (0);
	read_file(fd, 0);
	read_file(fd, 0);
	read_file(fd, 0);
	read_file(fd, 0);
	read_file(fd, 0);
	close(fd);
//	write(1, "\n", 1);
}
*/

==== /home/dthoo/temp/get/get_next_line.h ====


#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <unistd.h>
# include <stdlib.h>

# ifndef BUFFER_SIZE

#  define BUFFER_SIZE 1024

# endif

typedef struct s_var
{
	char	buf[BUFFER_SIZE];
	ssize_t	count;
	ssize_t	lim;
	int		fd;
}			t_var;

char	*get_next_line(int fd);
int		get_strjoin(char **a, char *b, ssize_t i, ssize_t k);
void	refresh_buffer(t_var *file, int fd);

#endif

==== /home/dthoo/temp/get/get_next_line_utils.c ====


#include "get_next_line.h"

int	get_strjoin(char **dst, char *b, ssize_t i, ssize_t k)
{
	char	*ret;
	char	*a;

	a = *dst;
	i = 0;
	k = 0;
	while (a[i])
		i ++;
	while (b[k])
		k ++;
	ret = malloc((i + k + 1) * sizeof(char));
	if (ret)
	{
		ret[i + k] = '\0';
		while (k--)
			ret[i + k] = b[k];
		while (i--)
			ret[i] = a[i];
	}
	free(a);//OH POINTERS
	free(b);//oh pointers
	*dst = ret;
	return (!ret);
}

void	refresh_buffer(t_var *file, int fd)
{
	ssize_t	i;

	i = 0;
	while ((fd != file->fd || fd < 0) && i < BUFFER_SIZE)
		file->buf[i++] = '\0';
	if (fd >= 0)
		file->lim = read(fd, file->buf, BUFFER_SIZE);
	i = 0;
	file->count = 0;
	if (fd < 0)
		file->lim = -1;
	while ((file->lim < 1) && i < BUFFER_SIZE)
		file->buf[i++] = '\0';
	file->fd = fd;
}

==== /home/dthoo/temp/get/ohno/get_next_line.c ====


#include "get_next_line.h"
//#include <unistd.h>

//void ft_putnbr(int n);

char	*read_buf(t_var *file, int fd, int *done)
{
	ssize_t	i;
	ssize_t	k;
	char	*ret;

	k = -1;
	if (file->count >= file->lim || fd != file->fd)//if buffer used or file change
		refresh_buffer(file, fd);
	if (file->lim < 1)//err or eof
		return ((*done = file->lim + !file->lim), NULL);//if 0, 1. if -1, -1
	i = file->count;//41 or less
	while (file->count < file->lim && file->buf[file->count] != '\n')//hm
		file->count ++;
	*done = (file->count < file->lim && file->buf[file->count] == '\n');//if count == 42, not done
	file->count += *done;//exclude !read
	ret = malloc(((file->count - i) + 1) * sizeof(char));
	if (!ret)
		return ((*done = -1), NULL);
	while (i + ++k < file->count)
		ret[k] = file->buf[i + k];
	ret[k] = '\0';
	return (ret);
}

int	gnl_new(t_gnllist **lst, char *ret, int *done)
{
	t_gnlnode	*new;
	int			i;

	new = malloc(sizeof(t_gnlnode));
	if (!new)
		return ((*done = -1), 0);
	new->str = ret;
	new->next = NULL;
	i = 0;
	while (ret[i])
		i ++;
	if (*lst)
		(*lst)->tail->next = new;
	if (!*lst)
	{
		*lst = malloc(sizeof(t_gnllist));
		if (!*lst)
			return ((*done = -1), 0);
		(*lst)->head = new;
		(*lst)->node_count = 0;
	}
	(new)->str_len = i;
	(*lst)->node_count += 1;
	(*lst)->tail = new;
	return (0);
}

int	gnl_shove(t_gnllist *lst, char **ret)
{
	int			i;
	int			k;
	t_gnlnode	*curr;

	*ret = NULL;
	curr = lst->head;
	i = 0;
	while (curr)
	{
		i += curr->str_len;
		curr = curr->next;
	}
	*ret = malloc((i + 1) * sizeof(char));
	if (!*ret)
		return (-1);
	i = 0;
	curr = lst->head;
	while (curr)
	{
		k = -1;
		while (curr->str[++k])
			(*ret)[i + k] = curr->str[k];
		i += k;
		curr = curr->next;
	}
	(*ret)[i] = '\0';
	return (1);
}

void	gnl_cleanup(t_gnllist *lst, char **ret, t_var *file, int done)
{
	t_gnlnode	*curr;
	t_gnlnode	*tmp;

	if (!lst || !done)
		return ;
	curr = lst->head;
	while (curr)
	{
		if (curr->str && curr->str != *ret)
			free(curr->str);
		tmp = curr->next;
		free(curr);
		curr = tmp;
	}
	if (done < 0)
	{
		if (*ret)
			free(*ret);
		file->count = 0;
		file->lim = 0;
		*ret = NULL;
	}
	free(lst);
}
char	*get_next_line(int fd)
{
	static t_var	file;//you wanna just do the static arr for mand? 
	t_gnllist		*lst;
	char			*ret;
	int				done;

	done = 0;
	lst = NULL;
	ret = NULL;
	while (!done)// no more var space, -1 is err
	{
		ret = read_buf(&file, fd, &done);//set done on \n or !read pls	
		if (!ret)
			break ;
		gnl_new(&lst, ret, &done);//change it later and move this up two lines
	}
	if (done == 1 && lst)
		done = gnl_shove(lst, &ret);
	gnl_cleanup(lst, &ret, &file, done);//can be shoved in here...?
	return (ret);
}
/*
#include <fcntl.h>

void ft_putstr(char *a, int flag)
{
	int i = 0;
	if (!a)
	{
		ft_putstr("(null)\n", 0);
		return ;
	}
	while (a[i])
		i ++;
	if (a[i - 1])
		;
	ft_putnbr(i);
	write(1, a, i);
	if (flag)
	{
		if (a[i - 1] == '\n')
			write(1, "nl\n", 3);
		else
			write(1, "empty\n", 6);
	}
}

void ft_putnbr(int n)
{
	int t = 1;
	char a;
	while (n / t > 9)
		t *= 10;
	while (t)
	{
		a = ((n / t) % 10) + 48;
		write(1, &a, 1);
		t /= 10;
	}
	write(1, "\n", 1);
}

int ft_strlen(char *a)
{
	int i = 0;
	while (a && a[i])
		i ++;
	return (i);
}

void read_file(int fd, size_t lines)
{
	char *a;
	if (!lines)
		lines = -1;
	while (lines--)
	{
		a = get_next_line(fd);
		
		if (a && a[0] == '\n')
			ft_putstr("nl\n", 0);
		if (a && a[0] == '\0')
			ft_putstr(".\n", 0);
		
		ft_putstr(a, 1);
		//ft_putnbr(ft_strlen(a));
		if (!a)
			return ;
		free(a);
	}
}

int main(int c, char **v)
{
	if (c < 2)
		return (1);
	ft_putnbr(BUFFER_SIZE);
	(void) v;
	int fd = open(v[1], O_RDONLY);
	if (fd < 0)
		return (1);
	read_file(fd, 0);
//	close(fd);
//	fd = open("not_a_file.txt", O_WRONLY);
//	fd = -100;
//	read_file(fd, 0);
//	fd = open(v[1], O_RDONLY);
//	if (fd < 0)
//		return (0);
	read_file(fd, 0);
	read_file(fd, 0);
*/
//==== /home/dthoo/temp/get/ohno/get_next_line.h ====


#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <unistd.h>
# include <stdlib.h>

# ifndef BUFFER_SIZE

#  define BUFFER_SIZE 1024

# endif

typedef struct s_var
{
	char	buf[BUFFER_SIZE];
	ssize_t	count;
	ssize_t	lim;
	int		fd;
}			t_var;

typedef struct s_gnlnode
{
	char				*str;
	struct s_gnlnode	*next;
	int					str_len;
}						t_gnlnode;

typedef struct s_gnllist
{
	t_gnlnode			*head;
	t_gnlnode			*tail;
	int					node_count;
}						t_gnllist;

char	*get_next_line(int fd);
int		get_strjoin(char **a, char *b, ssize_t i, ssize_t k);
void	refresh_buffer(t_var *file, int fd);

#endif

//==== /home/dthoo/temp/get/ohno/get_next_line_utils.c ====


#include "get_next_line.h"
/*
int	get_strjoin(char **dst, char *b, ssize_t i, ssize_t k)
{
	char	*ret;
	char	*a;

	a = *dst;
	i = 0;
	k = 0;
	while (a[i])
		i ++;
	while (b[k])
		k ++;
	ret = malloc((i + k + 1) * sizeof(char));
	if (ret)
	{
		ret[i + k] = '\0';
		while (k--)
			ret[i + k] = b[k];
		while (i--)
			ret[i] = a[i];
	}
	free(a);//OH POINTERS
	free(b);//oh pointers
	*dst = ret;
	return (!ret);
}
*/
void	refresh_buffer(t_var *file, int fd)
{
	ssize_t	i;

	i = 0;
	while ((fd != file->fd || fd < 0) && i < BUFFER_SIZE)//panic
		file->buf[i++] = '\0';
	if (fd >= 0)//on call
		file->lim = read(fd, file->buf, BUFFER_SIZE);//reads 42 or less
	i = 0;
	file->count = 0;
	if (fd < 0)
		file->lim = -1;//schizo
	while ((file->lim < 1) && i < BUFFER_SIZE)//panic again
		file->buf[i++] = '\0';
	file->fd = fd;//single fd system
}
